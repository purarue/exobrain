#!/bin/bash
# This builds the markdown files into HTML files.
# This runs pandoc by searching for README.md files recursively
# and running pandoc against that with the assets/template.html as a base
#
# additionally:
# runs pmark scripts: https://github.com/seanbreckenridge/pmark
# checks the yaml frontmatter to validate meta tags

# cd to this dir
cd "$(dirname "${BASH_SOURCE[0]}")" || exit

script_name="$(basename "${BASH_SOURCE[0]}")"

havecmd() {
	local BINARY ERRMSG
	BINARY="${1:?Must provide command to check}"
	if command -v "$BINARY" >/dev/null 2>&1; then
		return 0
	else
		ERRMSG="'$script_name' requires '$BINARY', could not find that on your \$PATH"
		if [[ -n "$2" ]]; then
			ERRMSG="$ERRMSG. $2"
		fi
		printf '%s\n' "$ERRMSG" 1>&2
		return 1
	fi
}

set -e
havecmd fd
havecmd curl
havecmd entr
havecmd pandoc
havecmd perl
havecmd go
havecmd jq
havecmd python
havecmd figlet
havecmd wait-for-internet "Install from <https://github.com/seanbreckenridge/wait-for-internet> (or just remove the line from the ./build script)"
havecmd pmark "Install from <https://github.com/seanbreckenridge/pmark>"
set +e
havecmd html-minifier "Install with 'npm install -g html-minifier'" && HAS_HTML_MINIFIER=1

wait-for-internet >/dev/null 2>&1

# creates the manifest file (directories which have posts)
mkmanifest() {
	declare line
	while IFS= read -r line; do
		line=${line#./}
		[[ "$line" == . ]] && continue
		echo "$line"
	done <<<"$(find . -name 'README.md' -printf "%h\n" | sort -d)" >MANIFEST
}

# minify HTML, from $1 to $2
minify_html() {
	html-minifier --collapse-boolean-attributes --collapse-whitespace --remove-comments --remove-optional-tags --remove-redundant-attributes --remove-script-type-attributes --remove-style-link-type-attributes --remove-tag-whitespace "$1" -o "$2"
	return $?
}

# converts $1 to $2 using pandoc
pandoc_generate() {
	local html_temp
	if [[ -n "$HAS_HTML_MINIFIER" ]]; then
		html_temp="$(mktemp -p /tmp exobrain-XXXXXXXXXXXXX.html)"
		if pandoc -s -o "$html_temp" --quiet --template=assets/template.html "$1"; then
			if minify_html "$html_temp" "$2"; then
				return 0 # succeeded, exit early
			else
				printf 'Error rendering %s to %s\n' "$1" "$2" >&2
				# drop through and do default render
			fi
		fi
	fi
	pandoc -s -o "$2" --quiet --template=assets/template.html "$1"
	return $?
}

# generate JSON to validate attributes in metadata (i.e. yaml frontmatter)
metadata_generate() {
	pandoc --from=markdown-smart --to=plain --template=./assets/meta.template "$1" >"$2"
}

render() {
	local dir
	readonly dir="$1"
	if [[ "$2" == "meta" ]]; then
		metadata_generate "${dir}/README.md" "${dir}/meta.json"
		printf "."
	else
		echo Building "'$dir'"
		pandoc_generate "${dir}/README.md" "${dir}/index.html"
	fi
}

run_build() {
	local i procs

	# make sure corresponding README files exist for P_README files
	# so that the directories appear in the manifest
	# (since this uses the presence of a README.md file to determine the existence of a node)
	# this only really matters the first time pmark is run on a P_README.md file,
	# but its not that much overhead anyways
	fd '^P_README.md$' | sed "s/P_//g" | xargs touch

	# remove old metadata files
	find . -name 'meta.json' -delete

	# render home page
	render "."
	# generate 404 page
	pandoc_generate "./404.md" "./404.html"
	# make manifest
	mkmanifest

	# get cpu count to determine how many jobs to run at a time
	procs="$(nproc)"
	[[ -z "$procs" ]] && procs=4
	procs=$((procs * 2))

	printf "Building metadata..."
	while IFS= read -r node; do
		render "$node" meta &
	done <MANIFEST
	wait
	printf '\n'

	# run pmark on each P_README.md file
	# builds the blog feed/sitemap and curls the project page
	# see https://github.com/seanbreckenridge/pmark
	fd '^P_README.md$' -X pmark || exit $?

	i=0
	while IFS= read -r node; do
		render "$node" &
		((i++))
		((i >= procs)) && {
			wait
			i=0
		}
	done <MANIFEST
	wait
	# remove temp exobrain files
	printf 'Removed %d temporary /tmp/exobrain-* files\n' "$(rm -fv /tmp/exobrain-* | wc -l)"
	# check for yaml frontmatter errors
	if go run ./harden.go; then
		echo "No formatting errors found."
	else
		return 1
	fi
}

run_build || exit $?
figlet -f 'script' 'done!'
