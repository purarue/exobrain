#!/bin/bash
# This builds the markdown files into HTML files.
# This runs pandoc by searching for README.md files recursively
# and running pandoc against that with the assets/template.html as a base
#
# additionally:
# runs pmark scripts: https://github.com/seanbreckenridge/pmark
# checks the yaml frontmatter to validate meta tags

script_name="$(basename "${BASH_SOURCE[0]}")"

havecmd() {
	local BINARY ERRMSG
	BINARY="${1:?Must provide command to check}"
	if command -v "$BINARY" >/dev/null 2>&1; then
		return 0
	else
		ERRMSG="'$script_name' requires '$BINARY', could not find that on your \$PATH"
		if [[ -n "$2" ]]; then
			ERRMSG="$ERRMSG. $2"
		fi
		printf '%s\n' "$ERRMSG" 1>&2
		return 1
	fi
}

set -e
havecmd fd
havecmd curl
havecmd entr
havecmd pandoc
havecmd perl
havecmd go
havecmd wait-for-internet "Install it from https://github.com/seanbreckenridge/wait-for-internet (or just remove it from the ./build script)"
havecmd pmark "Install it from 'https://github.com/seanbreckenridge/pmark'"
set +e
havecmd html-minifier "Install with 'npm install -g html-minifier'"

wait-for-internet >/dev/null 2>&1

cd "$(dirname "${BASH_SOURCE[0]}")" || exit

command -v html-minifier >/dev/null 2>&1 && HAS_HTML_MINIFIER=1

# creates the manifest file (directories which have posts)
mkmanifest() {
	declare line
	while IFS= read -r line; do
		line=${line#./}
		[[ "$line" == . ]] && continue
		echo "$line"
	done <<<"$(find . -name 'README.md' -printf "%h\n" | sort -d)" >MANIFEST
}

# converts $1 to $2 using pandoc
pandoc_generate() {
	local html_temp
	html_temp="$(mktemp -p /tmp exobrain-XXXXXXXXXXXXX.html)"
	if [[ -n "$HAS_HTML_MINIFIER" ]]; then
		if pandoc -s -o "$html_temp" --quiet --template=assets/template.html "$1"; then
			if html-minifier --collapse-boolean-attributes --collapse-whitespace --remove-comments --remove-optional-tags --remove-redundant-attributes --remove-script-type-attributes --remove-style-link-type-attributes --remove-tag-whitespace "$html_temp" -o "$2"; then
				return # succeeded, exit early
			else
				printf 'Error rendering %s to %s\n' "$1" "$2" >&2
				# drop through and do default render
			fi
		fi
	fi
	pandoc -s -o "$2" --quiet --template=assets/template.html "$1"
}

# generate JSON to validate attributes in metadata (i.e. yaml frontmatter)
metadata_generate() {
	local readme json_frontmatter
	readme="${1}/README.md"
	json_frontmatter="${1}/meta.json"
	pandoc --from=markdown-smart --to=plain --template=./assets/meta.template "$readme" >"$json_frontmatter"
}

render() {
	local dir
	dir="$1"
	echo Building "'$dir'"
	metadata_generate "$dir" &
	pandoc_generate "$dir/README.md" "$dir/index.html"
}

run_build() {
	local i procs

	# make sure corresponding README files exist for P_README files
	# so that the directories appear in the manifest
	# (since this uses the presence of a README.md file to determine the existence of a node)
	# this only really matters the first time pmark is run on a P_README.md file,
	# but its not that much overhead anyways
	fd '^P_README.md$' | sed "s/P_//g" | xargs touch

	# render home page
	render "."
	# generate 404 page
	pandoc_generate "./404.md" "./404.html"
	# make manifest
	mkmanifest

	# run pmark on each P_README.md file
	# builds the blog feed/sitemap and curls the project page
	# see https://github.com/seanbreckenridge/pmark
	fd '^P_README.md$' -X pmark || exit $?

	# get cpu count to determine how many jobs to run at a time
	procs="$(nproc)"
	[[ -z "$procs" ]] && procs=4
	procs=$((procs * 2))

	i=0
	while IFS= read -r node; do
		render "$node" &
		((i++))
		((i >= procs)) && {
			wait
			i=0
		}
	done < <(shuf ./MANIFEST)
	wait
	# remove temp exobrain files
	printf 'Removed %d temporary /tmp/exobrain-* files\n' "$(rm -fv /tmp/exobrain-* | wc -l)"
	# check for yaml frontmatter errors
	if go run ./harden.go; then
		echo "No formatting errors found."
	fi
}

run_build || exit $?
echo 'Done!'
