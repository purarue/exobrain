<!doctype html>
<html lang="en">
<head>
            <title>exobrain | Bash Notes</title>
        <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <link rel="shortcut icon" href="/assets/img/logo.png" type="image/png">
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <link rel="stylesheet" href="/assets/style.css">
</head>
<body>
<header class=nav-bar>
  <nav>
          <a class="homelink" href="/">exobrain</a>
        <div class="nav-right">
      <div class=nav-item><a class="nav-link" href="/feed">blog feed</a></div>
      <div class=nav-item><a class="nav-link" href="/sitemap">exobrain sitemap</a></div>
      <div class=nav-item><a class="nav-link" href="https://sean.fish">back to my site</a></div>
    </div>
  </nav>
</header>
<main>
<a id=top></a><div class=container>
<div id="main-header">
  <div class="h1" id="main-title">Bash Notes</div>
  </div>
<p>Use bash substitutions when possible instead of <code>sed</code>/<code>awk</code>.</p>
<h4 id="auto-expanding-variable-contents">Auto expanding variable contents:</h4>
<pre><code># special syntax to expand \n to actual newline in string
name=$&#39;Sean\nBreckenridge&#39;
echo &quot;$name&quot; # recieves one argument

# weird printf trickery
printf &quot;%s&quot; $name # auto expands to two arguments, only prints &#39;Sean&#39;
printf &quot;%s %s&quot; $name # printf receives two arguments

# safest is to quote your variables
printf &quot;%s&quot; &quot;$name&quot; </code></pre>
<hr />
<h4 id="modifying-ifs-to-read-into-arrays">Modifying IFS to read into arrays:</h4>
<p>You can use <code>$'\n'</code> to expand an actual newline into the internal field separator, and then use a subshell to split lines into an array:</p>
<pre><code>declare -a dircontents
IFS=$&#39;\n&#39; dircontents=($(ls -1))
for val in &quot;${dircontents[@]}&quot;; do
  echo &quot;value: ${val}&quot;
done</code></pre>
<p>The default value for <code>IFS</code> is whitespace.</p>
<hr />
<p>Maybe look into <code>perl</code> instead of <code>sed</code>/<code>awk</code>/<code>tr</code>/<code>cut</code>, look at <code>perlre</code> and <code>perlrun</code> man pages.</p>
<p>Startup time for running a script is much more than using an exported function or alias, but it also makes it less portable. Despite there being a huge difference, to the human eye its typically not noticeable.</p>
<p>Read the bash man page! Bashisms can be bad if you’re trying to be POSIX compliant, but bashisms also save lots of time.</p>
<p>You may need to use POSIX complaint code for something like Solaris SVR4 packages which requires Bourne shell for any scripts.</p>
<h4 id="early-exit">Early Exit</h4>
<p>Print message to STDERR if value is unset and exit:</p>
<pre><code># if $1 is unset/empty
USER_INPUT=&quot;${1:?must provide something as first argument}&quot;</code></pre>
<hr />
<p><code>2&gt;/dev/null 1&gt;&amp;2</code> to completely silence a script, <code>echo something &gt;&amp;2</code> (or <code>1&gt;&amp;2</code>) to print an error.</p>
<hr />
<h4 id="extensions">Extensions</h4>
<p><code>.sh</code> at the end of scripts is only necessary if you’re creating libraries, or if you’re for some reason in windows land. Otherwise you’re only making yourself do more typing. If you’re making libraries, there is no shebang line and there shouldn’t be - its meant to be <code>source</code>d into some other script. If its a library, it should have a <code>.sh</code> or <code>.bash</code> extension and the file shouldn’t be executable.</p>
<hr />
<p>Use short circuiting when doing simple tests, case statements for basic subcommands, and getopts if you want to have short and long (<code>-h</code>, <code>--help</code>) options for consistency/larger programs.</p>
<p>SUID/SGID are forbidden on shell scripts (running as owner as script instead of person executing the script). Too many security risks that come along with using that, use <code>sudo</code> if you need elevated access.</p>
<h4 id="stylingformatting">Styling/Formatting</h4>
<p>Notes from <a href="https://google.github.io/styleguide/shellguide.html">Google StyleGuide</a>:</p>
<p>Don’t need to use the <code>function</code> keyword, as its optional. Also, there aren’t really functions, they’re procedures/methods. No reason to break POSIX compliance and using <code>function</code>.</p>
<p>Using hyphens (or nothing) instead of underscores for variable/script names.</p>
<p>I tend to just use <a href="https://github.com/mvdan/sh"><code>shfmt</code></a> for everything.</p>
<p>HEREDOCs that have indentation need tabs, so it can make formatting confusing - so they need to left justified. You can use a dash to chomp tabs, but then it removes <em>all</em> surrounded tabs.</p>
<p>One can use embedded newlines:</p>
<pre><code>some_string=&quot;I am a string
with multiple lines&quot;</code></pre>
<p>Don’t but <code>do</code> and <code>then</code> on their own line when using <code>for</code>/<code>if</code> loops:</p>
<pre><code>for ....; do
  expression
done
if ....; then
  expression
done</code></pre>
<p>Using semicolons makes the indent more obvious.</p>
<p>When doing <em>lots</em> of parameter expansion when doing an echo, would make more sense to separate that into another variable, or use <code>printf</code>. Avoid stuff like:</p>
<pre><code>echo &quot;${1}0${2}0${3}&quot;</code></pre>
<p>Quoting:</p>
<ul>
<li><em>Always quote your strings!</em> Often better to ‘over-quote’ than to get an error with shell expansion.</li>
<li>Never quote literal integers</li>
<li>Use <code>"$@"</code> unless you have a specific reason to use <code>$*</code>, like splatting in the individual elements into a string: <code>"search?q=$*"</code></li>
<li>Single quotes doesn’t do any shell substitution.</li>
<li>Always do shell expansion</li>
</ul>
<p>It may not be necessary, but always quote your command substitutions to be safe:</p>
<pre><code>some_val=&quot;$(subshell command &quot;$@&quot;)&quot;</code></pre>
<p><code>readonly</code> is a synonym for <code>declare -r</code>, which makes a variable constant.</p>
<pre><code>FLAGS=( --foo --bar=&#39;baz&#39; )
readonly FLAGS</code></pre>
<p>Don’t need to quote variables in arithmetic subshells</p>
<pre><code>if (( $# &gt; 3 )); then
  echo &quot;too many arguments&quot;
fi</code></pre>
<p>Don’t need to quote literal integers, but you may want to single quote words:</p>
<pre><code>exit_code=3
some_value=&#39;true&#39;</code></pre>
<p>Use <code>$(command)</code> instead of back ticks. Nested back ticks require escaping the inner ones. <code>$(command)</code> doesn’t change and is easier to read:</p>
<pre><code># Do:
var=&quot;$(command &quot;$(command)&quot;)&quot;
# instead of:
var=&quot;`command \`command\``&quot;</code></pre>
<p>Use <code>[[ ... ]]</code> instead of <code>[ ... ]</code>, <code>test</code> and <code>/usr/bin/[</code> to avoid POSIX issues. <code>[[ ]]</code> is <strong>built-in</strong> to bash, doing <code>[</code> causes you to do a subshell out to the <code>[</code> command, and offers you the advantage that:</p>
<p><code>[[ ... ]]</code> reduces errors as no pathname expansion or word splitting takes place. To exemplify what that means, you can do <code>[[ $VAR == test ]]</code>, without worrying about <code>$VAR</code> expanding to multiple words. You can still do <code>"$VAR"</code>, but its not required.</p>
<p>This also means when you’re doing regex, you can splat a variable into a regex to test against a string:</p>
<pre><code>[[ $filename =~ ^[[:alnum:]]+$pattern ]]</code></pre>
<p>For regex:</p>
<pre><code># this matches
[[ &quot;filename&quot; == f* ]]
# this doesnt
[[ &quot;filename&quot; == &quot;f*&quot; ]]</code></pre>
<p>Bash is smart enough to deal with empty strings in test. (<code>/usr/bin/[</code> is not!)</p>
<p>Use <code>-z</code> to empty strings, and <code>-n</code> to test if strings has value:</p>
<pre><code>[[ -z &quot;$1&quot; ]] &amp;&amp; echo &quot;argument is empty&quot;
[[ -n &quot;$1&quot; ]] &amp;&amp; echo &quot;argument has value: ${1}&quot;</code></pre>
<p>Using <code>(( ... ))</code> makes sure that the values are integers, don’t have to use <code>$</code> and means you don’t have to use <code>-gt</code> or <code>-lt</code> in <code>[[ .. ]]</code>:</p>
<pre><code>if (( some_var &gt; 3 )); then

fi</code></pre>
<p>Use an explicit <code>./</code> path when doing wildcard expansion of filenames:</p>
<pre><code>find . -name &quot;./*.txt&quot;</code></pre>
<p><strong>Don’t use <code>eval</code></strong>.</p>
<h3 id="arrays">Arrays</h3>
<p>Arrays should be used for lists of items, to avoid complications with quoting.</p>
<p>Using a single string to multiple command arguments to another command should be avoided, as it leads to having to either doing an eval or parameter expansion.</p>
<pre><code># Do this:
declare -a flags
flags=(--foo --bar=&#39;baz&#39;)
flags+=(--greeting=&quot;Hello ${name}&quot;)
binary_command &quot;${flags[@]}&quot;
# Instead of:
flags=&#39;--foo --bar=baz&#39;
flags+=&#39; --greeting=&quot;Hello world&quot;&#39; # not trivial to do variable expansion
binary_command &quot;${flags}&quot;</code></pre>
<p>Command expansions return single strings, not arrays. Avoid trying to capture subshell into array assignments since it won’t work if the command contains special characters or whitespace. Better to read into a string and then use <code>readarray</code></p>
<h4 id="piping-to-while">Piping to While</h4>
<p>Use process substitution or <code>readarray</code> instead of directly piping into while. Pipes create subshells, so the block in the while loop doesn’t have access to un-exported variables in the script, and can’t change anything in the parent shell.</p>
<p><em>Don’t do this:</em></p>
<pre><code>my_variable=&#39;something&#39;
command | while read -r line; do
  my_variable+=&quot;${line}\n&quot;
done
echo &quot;$my_variable&quot;  # prints &#39;something&#39;, wasnt modified in loop</code></pre>
<p><em>Do this instead:</em></p>
<pre><code>my_variable=&#39;something&#39;
while read -r line; do
  my_variable+=&quot;${line}\n&quot;
done &lt; &lt;(command)</code></pre>
<p>That leaves the while loop in the parent process, but still runs the command in a subshell.</p>
<p>You can also:</p>
<pre><code>my_variable=&#39;something&#39;
command_output=&quot;$(command)&quot;
while read -r line; do
  my_variable+=&quot;${line}\n&quot;
done &lt;&lt;&lt;&quot;$command_output&quot;</code></pre>
<p>… which sends the string into <code>STDIN</code>.</p>
<p>Another alternative with <code>readarray</code>:</p>
<pre><code>my_variable=&#39;something&#39;
readarray -t lines &lt; &lt;(command)
for line in &quot;${lines[@]}&quot;; do
  my_variable+=&quot;${line}\n&quot;
done</code></pre>
<hr />
<p>Should be careful about using a for-loop to iterate over output using <code>for something in $(...)</code>, since the output is split by whitespace, not by line. This can be safe, if you’re sure the subshell output can’t contain whitespace, but <code>while</code> with <code>readarray</code> is often safer.</p>
<p><code>&lt;</code> and <code>&gt;</code> in <code>[[ ... ]]</code> perform <strong>lexicographic</strong>, not numerical comparisons.</p>
<h3 id="math-subshells">Math subshells:</h3>
<pre><code># do some simple arithmetic and print it
echo &quot;$(( 2 + 2)) is 4&quot;
# assign to variable
(( i = 10 * j + 400))
echo &quot;$i&quot;</code></pre>
<p><code>let</code> isn’t <code>declare</code> or <code>local</code> - just avoid it.</p>
<p>Stylistic considerations aside, shell built-in arithmetic is way faster than a subshell out to <code>expr</code> - avoid it.</p>
<h3 id="localdeclare">Local/Declare</h3>
<p><code>local</code> and <code>declare</code> have the same flags. <code>declare</code> works a global level and <code>local</code> works in functions.</p>
<p>same thing:</p>
<pre><code>readonly SOME_PATH=&#39;/some/path&#39;
declare -r SOMEPATH=&#39;/some/path&#39;</code></pre>
<pre><code># makes constant and exports variable:
declare -rx SOMEPATH=&#39;/some/path&#39;</code></pre>
<p>Can set a variable to be readonly after checking opts:</p>
<pre><code>VERBOSE=&#39;false&#39;
while getopts &#39;v&#39; flag; do
  case &quot;${flag}&quot; in
    v) VERBOSE=&#39;true&#39; ;;
  esac
done
readonly VERBOSE</code></pre>
<h3 id="clobbering-exit-codes">Clobbering Exit Codes</h3>
<p>You should separate the declaration of <code>declare</code> and <code>local</code> from its <code>RHS</code> value if that includes a call to a subshell which could fail. For example:</p>
<pre><code>declare my_var=&quot;$(command)&quot;
(( $? == 0 )) || return</code></pre>
<p>will <em>always</em> succeed, since the <code>declare</code> returns a 0 exit code.</p>
<p>Should instead do:</p>
<pre><code>declare my_var
my_var=&quot;$(command)&quot;
(( $? == 0))</code></pre>
<p>When a script gets large enough, you may start separating parts into functions. That means that an <code>exit</code> that may have previously existed wouldn’t exit the script, but instead the function. Those should be converted to <code>return</code> and then the main invocation to the function should be <code>||</code>’d or <code>(( $? == 0))</code>d against. This also leads itself well to exporting functions in <code>bash</code> for interactive use.</p>
<p>So, it makes more sense to create a <code>main</code> or top-level function that includes your entire script, like:</p>
<pre><code>main() {
  [ -z &quot;$1&quot; ] &amp;&amp; {
    echo &quot;error&quot; &gt;&amp;2
    return 1
  }
}

main &quot;$@&quot; || exit $?</code></pre>
<p>For short scripts that just once from top to bottom, that’s slight overkill, but once you’re doing lots of <code>getopts</code>/<code>validation</code> or have a sufficient amount of functionality, it makes sense to do that.</p>
<h3 id="checking-return-values">Checking Return Values</h3>
<p>Instead of explicitly checking <code>$?</code> to check the error code, you can use an if statement, or just a <code>||</code> with curly brackets:</p>
<pre><code>if ! mv &quot;$something&quot; &quot;$somewhere&quot;; then
  echo &quot;Error, couldnt move ${something}&quot;
  exit 1
fi

# or...
if ! some_error=&quot;$(mv &quot;$something&quot; &quot;$somewhere&quot;)&quot;; then
  echo &quot;$some_error&quot;
  exit 1
fi

# or...
mv &quot;$something&quot; &quot;$somewhere&quot; || {
  echo &quot;Error, couldn&#39;t move ${something}&quot;
  exit 1
}</code></pre>
<p>Bash also has <code>PIPESTATUS</code> that lets you check the return code from every part of a pipe.</p>
<pre><code>tar -cf - ./* | ( cd &quot;${dir}&quot; &amp;&amp; tar -xf - )
if (( PIPESTATUS[0] != 0 || PIPESTATUS[1] != 0 )); then
  echo &quot;Unable to tar files to ${dir}&quot; &gt;&amp;2
fi</code></pre>
<p>Another alternative if you’re pipelining text is to use <code>xargs -r</code>, which doesn’t run if the STDIN is empty, which is typically the case if a command failed:</p>
<pre><code>some_command_that_might_print_nothing | xargs -r -I &quot;{}&quot; echo &quot;{}&quot;</code></pre>
<p>Notes from: <a href="https://www.youtube.com/watch?v=uqHjc7hlqd0" class="uri">https://www.youtube.com/watch?v=uqHjc7hlqd0</a></p>
<p>For help: <code>type</code>, <code>help</code>, <code>apropos</code>, <code>man</code>, <code>info</code></p>
<p>Return value of the last command executed is captured in the special parameter <code>$?</code>.</p>
<h4 id="loops">loops</h4>
<p><code>while list1; do list2; done</code></p>
<p>Execute <code>list1</code>; if success, execute list2 and repeat. Continue until list1 returns a non-zero status (fails).</p>
<p><code>for name in words; do list; done</code></p>
<p>Can also use an arithmetic expression, with look like C-styled for loops:</p>
<p><code>for (( expr1; expr2; expr3 )); do list; done</code></p>
<p><code>select name in words; do list; done</code></p>
<p>Create a menu item for each word. Provide the user with an interactive interface to select one of them. Each time the user makes a selection from the menu, <code>name</code> is assigned the value of the selected word and <code>REPLY</code> is assigned the <code>index</code> number of the selection.</p>
<pre><code>select result in Yes No Cancel Exit
    do
        if [ &quot;$result&quot; = &quot;Exit&quot; ]; then
        echo &quot;$result&quot;
        exit 0
        fi
        echo $result
    done</code></pre>
<p><code>[[ -t 0 ]]</code> can be used to check if <code>STDOUT</code> (file descriptor 0) refers to a terminal. It returns 0 if it is a terminal, and 1 if its being redirected input from some other command/file. This lets you choose to be interactive with the user, or assume some default value if its being called from a script.</p>
<h3 id="command-groups">Command Groups</h3>
<ul>
<li>Subshell: Evaluate list of commands in a subshell, has a distinct environment and does not affect the parent environment. <code>(list)</code></li>
<li>Group Command: Evaluate list of commands in the current shell, sharing the environment. <code>{ list; }</code> (spaces are trailing semicolon are obligatory)</li>
</ul>
<p>Something I never really comprehended, this is still a subshell, its just not assigning to some variable, so you don’t need to prepend the <code>$</code></p>
<p><code>(echo b; echo a) | sort</code></p>
<p>The <code>$(list)</code> replaces the output of the <code>list</code> in-line with the output of its subshell. Referred to as <em>command substitution</em>.</p>
<p><code>$$</code> is a special parameter that specifies your current PID.</p>
<h3 id="parameters">Parameters</h3>
<p>Like <code>${param:-$HOME}</code>, <code>${param:=$HOME}</code> returns <code>$HOME</code> if <code>${param}</code> is empty or unset, but it <em>also</em> sets <code>param</code> to <code>$HOME</code>, without you having to do the assignment explicitly.</p>
<p>Can think of these as:</p>
<p>Removal from left edge:</p>
<ul>
<li><code>${param#pattern}</code></li>
<li><code>${param##pattern}</code> ( greedy match )</li>
</ul>
<pre><code>[ ~ ] $ echo ${HOME}
/home/sean
[ ~ ] $ echo ${HOME#*/}
home/sean
[ ~ ] $ echo ${HOME##*/}
sean</code></pre>
<p>Reminder that <code>*</code> is the typical posix globbing, its matching zero or more of any character (<code>.*</code> in PCRE terms)</p>
<p>Removal from right edge</p>
<ul>
<li><code>${param%pattern}</code></li>
<li><code>${param%%pattern}</code></li>
</ul>
<p>Can search the env for names matching something (this parameter expansion doesnt work in <code>zsh</code>):</p>
<pre><code>$ echo &quot;${!XDG_@}&quot;
XDG_CACHE_HOME XDG_CONFIG_HOME XDG_CURRENT_DESKTOP XDG_DATA_HOME XDG_GREETER_DATA_DIR XDG_RUNTIME_DIR XDG_SEAT XDG_SEAT_PATH XDG_SESSION_CLASS XDG_SESSION_DESKTOP XDG_SESSION_ID XDG_SESSION_PATH XDG_SESSION_TYPE XDG_VTNR</code></pre>
<h3 id="brace-expansion">brace expansion</h3>
<pre><code>$ echo ba{t,r}
bat bar</code></pre>
<p>Can also use this to generate words for something like a nested for loop:</p>
<pre><code>$ echo {1..5}{0,5}%
10% 15% 20% 25% 30% 35% 40% 45% 50% 55%
$ echo {10..55..5}%  # can also use a iterator to count by 5
10% 15% 20% 25% 30% 35% 40% 45% 50% 55%</code></pre>
<p>Functions receive input from STDIN, and send to STDOUT. The <code>{ }</code> is not required, its a Group Command, which often just makes things easier to read. For example:</p>
<pre><code>words ()
for word
do
  echo &quot;$word&quot;
  echo &quot;$word&quot; &gt;&amp;2
done 2&gt;/dev/null</code></pre>
<p>works fine, since the command there is the <code>for</code>.</p>
<p>A function definition is just a statement, so the <code>2&gt;/dev/null</code> means that when the function is called, all of the functions STDERR is ignored.</p>
<pre><code>$ words one two
one
two</code></pre>
<h2 id="session-portability">Session Portability</h2>
<p>Import elements from a current session directly into a new local or remote session.</p>
<pre><code>sudo bash -c &quot;
$(decalre -p parameters;
declare -f functions)
code and stuff&quot;</code></pre>
<p>… imports parameters and functions into the root shell, and then run <code>code and stuff</code></p>
<p>similarly, could use this with <code>ssh</code>:</p>
<pre><code>ssh remote@host &quot;
$(declare -f functionname)
functionname arguments&quot;</code></pre>
<p>References:</p>
<ul>
<li><a href="https://google.github.io/styleguide/shellguide.html" class="uri">https://google.github.io/styleguide/shellguide.html</a></li>
<li>bash man page</li>
</ul>
</div>
</main>
<footer>
  <p><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" id=copyright>© 2020 Sean Breckenridge. Licensed under Creative Commons Attribution-ShareAlike.</a>
    <br /><a href="https://github.com/seanbreckenridge/exobrain">Source Code</a>
  </p>
</footer>
<script src="/assets/main.js"></script>
</body>
</html>
