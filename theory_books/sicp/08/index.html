<!doctype html><html lang="en"><title>exobrain | SICP 08 - Local state variables, environments</title><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible"content="ie=edge"><meta http-equiv="Cache-Control"content="no-cache, no-store, must-revalidate"><link rel="shortcut icon"href="/assets/img/logo.png"type="image/png"><meta http-equiv="Pragma"content="no-cache"><meta http-equiv="Expires"content="0"><link rel="stylesheet"href="/assets/style.css"><header class="nav-bar"><nav><a class="homelink"href="/">exobrain</a><div class="nav-right"><div class="nav-item"><a class="nav-link"href="/feed">blog feed</a></div><div class="nav-item"><a class="nav-link"href="/sitemap">exobrain sitemap</a></div><div class="nav-item"><a class="nav-link"href="https://sean.fish">back to my site</a></div></div></nav></header><main><a id="top"></a><div class="container"><div id="main-header"><div class="h1"id="main-title">SICP 08 - Local state variables, environments</div></div><p>Read Section 3.1, 3.2<p>Read <a href="https://inst.eecs.berkeley.edu//~cs61a/reader/belowline.pdf">Object Oriented Programming | Below the line view</a><p>Encompasses Lecture 21, 22, 23<p>Modularity - can be divided “naturally” into coherent parts that can be separately developed and maintained.<p>Organizational Strategies:<ul><li>Objects - views a large system as a collection of distinct objects whose behaviours may change over time. Have to be concerned with how objects can change but still maintain its identity.<li>Streams - information flows by applying operations onto data. Can be exploited to apply operations lazily (delayed evaluation)</ul><h3 id="assignment-and-local-state">Assignment and Local State</h3><p>In a system composed of many objects, the objects are rarely completely independent. “A system composed of separate objects is most useful when state variables of the system can be grouped into closely coupled systems that are only loosely coupled to other subsystems”. That allows the entire system to be modular, and allows parts of the system to be tested and debugged separately, making maintenance easier.<p>In scheme, you can create local variables using the <code>let</code> keyword, so this would sort of create a ‘bank account’ (object, in an OOP sense), by using local scope and <code>set!</code><pre><code>(define new-withdraw
(let ((balance 100))
  (lambda (amount)
    (if (&gt;= balance amount)
      (begin (set! balance (- balance amount))
        balance)
      &quot;Insufficient funds&quot;))))</code></pre><p><code>new-withdraw</code> returns a <code>lambda</code>, whose <code>set!</code> refers to the locally defined <code>balance</code>.<p>Similarly, you could create a <code>make-account</code> procedure which returns a <code>dispatch</code> method, and use <code>'withdraw</code> or <code>'deposit</code> to <code>set!</code> the local <code>balance</code> variable.<p>Introducing state/local variables causes lots of confusion and problems, but it also simplifies otherwise complicated code. Consider seeding a random number generator. If we can’t save some initial seed value for a PRNG, every operation that needs a random number will have to have the result of the previous operation. This leads you to passing around an additional seed/PRNG value everywhere, else your methods are not purely functional. In haskell, this confusion is typed with a monad.<p>Introducing assignment means that you can no longer use the substitution model. It becomes harder to read code whose results can depend on multiple mutable global variables. “No simple model with ‘nice’ mathematical properties can be an adequate framework for dealing with objects and assignment in programming languages”.<p>‘A language that supports the concept that “equals can be substituted for equals” in an expression without changing the value of the expression is said to be <em>referentially transparent</em>’. Once you include <code>set!</code>, you’ve violated referential transparency. The meaning of ‘same’ becomes much harder to model.<p>Compare:<pre><code>(define peter-acc (make-account 100))
(define paul-acc (make-account 100))</code></pre><p>vs.<pre><code>(define peter-acc (make-account 100))
(define paul-acc peter-acc)</code></pre><p>This demonstrates the difference between comparing objects by value vs identity.<p>In general, so long as we never modify data objects, we can regard a compound data object to be precisely the totality of its pieces.<p>In imperative programming, since were not following the substitution model, the order of operations becomes much more important, and its possible to get incorrect answers by not considering how the order of operations affects local state of complex systems. This becomes even worse if operations execute in parallel, since its not always easy to determine which operations depend on each other.<h3 id="environment-model-of-evaluation">Environment Model of Evaluation</h3><p>An environment is a sequence of <em>frames</em>. Each frame is a table (possibly empty) of bindings, which associate variable bindings with values. Each frame points to a higher enclosing environment (except the global frame).<p>The value of a variable refers to the closest frame which include a binding to the symbol. If no frames include a binding, its said to be <em>unbound</em>.<figure><img src="images/scope.png"alt=""><figcaption>Simple environment structure</figcaption></figure><p>If in scope <code>II</code>, <code>x</code>’s value would be 7. The binding in <code>II</code> is said to <em>shadow</em> the binding of <code>x</code> to <code>3</code> in <code>I</code>.<p>For simplicity, you can think of the global environment as the highest scope, which includes bindings like <code>+</code> or <code>*</code>, which represent built-in symbols.<h4 id="rules-for-evaluation">Rules for evaluation</h4><p>For a procedure like:<pre><code>(define square
  (lambda (x) (* x x)))</code></pre><p>… the <code>square</code> symbol is then defined globally. Calling a <code>lambda</code> body creates a frame, which then has a pointer to the environment it was defined in.<figure><img src="images/function.png"alt=""><figcaption>Function Scope</figcaption></figure><p>In general, <code>define</code> creates definitions by adding bindings to frames.<p>To apply a procedure to arguments, create a new environment containing a frame that binds the parameters to the values of the arguments. The enclosing environment of this frame is the environment specified by the procedure (the enclosing frame of where the procedure was defined).<p>The Environment Model can be summarized by two rules:<ul><li>A procedure object is applied to a set of arguments by constructing a frame, binding the formal parameters of the procedure to the arguments of the call, and then evaluating the body of the procedure in the context of the new environment constructed. The new frame has as its enclosing environment the environment part of the procedure object being applied.<li>A procedure is created by evaluating a sexpr (lambda) relative to a given environment. The resulting procedure object is a pair consistent of the text of the sexpr and a pointer to the environment in which the procedure was created.</ul><p>Very simply:<ul><li>Substitution Model: <code>(eval expr)</code><li>Environment Model: <code>(eval expr environ)</code></ul><p>In scheme, <code>define</code> lets create bindings, and <code>set!</code> allow us to modify bindings. In the substitution model, theres often an implicit third <code>eviron</code> argument, which would be <code>theglobalenv</code> (the global frame)<figure><img src="images/balance.png"alt=""><figcaption>make-withdraw environment</figcaption></figure><p>Running <code>make-withdraw</code> multiple times would create separate environments, so the <code>balance</code> binding would use its own frame.<figure><img src="images/execution_balance.png"alt=""><figcaption>scope while executing</figcaption></figure><p>The <code>amount</code> is the formal parameter to the method, which is created each time the function is called. It points to the <code>E1</code> frame, which includes the <code>balance</code> binding, which points to the global frame.<p>The symbols/code that describe the <code>parameters</code> and <code>body</code> do not depend or change when the values in each account do, so they can be kept separately and shared across instances. Whether or not they actually are is an implementation detail, since it wouldn’t change the result, it would be an optimization that reduces memory usage.<figure><img src="images/shared.png"alt=""><figcaption>W1 and W2 share parameters/body</figcaption></figure><p>This method of symbol lookup is called lexical scoping. An alternative would be dynamic, where the lookup is determined by the most recent environment on the stack in a specific procedure call which has a formal parameter with the same symbol name. Dynamic scoping is much harder to optimize since lookups are done at runtime. Lexical scoping can allow you to do some optimizations, it allows you to know the offsets for binding lookups relative to the memory address of their environment at compile time.<p>Two key properties that make local procedure definitions a useful technique for modularizing programs:<ul><li>The names of local procedures do not interfere with names external to the enclosing procedure, because the local procedure names will be bound in the frame that the procedure creates when it is run, rather than being bound in the global environment.<li>The local procedure can access the arguments of the enclosing procedure, simply by using the parameter names as free variables (variables not defined as a formal parameter to a procedure). This is because the body of the local procedure is evaluated in an environment that is subordinate to the environment for the enclosing procedure.</ul><p>This often means that local procedure definitions which deal with state are easier to read and work how you expect them to, since they’re pointing at the ‘correct’ frames.<p>We could say that the environments that are created when lambdas are run are closures. Could be said that all bindings are just closures in some global frame, whose values are stored as a binding in the ‘global closure’. Which is true, but we often don’t think of it that way since its not incredibly helpful.<h3 id="message-passing">Message Passing</h3><p>Any OOP system that uses the message-passing model must have some below-the-line mechanism for associating methods with messages. This is typically done by binding a symbol/name.<p>If we are treating objects as an ADT, programs that use objects shouldn’t know that we happen to be representing objects as procedures. This can be fixed by wrapping the <code>dispatch</code> procedure:<pre><code>(if (method? method)
  (apply method args)
  (error &quot;No method&quot; message (cadr method)))</code></pre><h3 id="inheritance-and-delegation">Inheritance and Delegation</h3><p>It may make sense that all parent methods would just be copied into the child when a class is created, but it typically isn’t done that way. Its done through <em>delegation</em> - each object contains only the methods for its own class, and then a instance variable of the parent class. If the methods aren’t found in the child class, it passes a message to the parent class, which then passes to its parent if it can’t find the symbol.<p>Typically, the parent class instance variable is created when the class is defined, and would be shared across instances.<p>A downside of the delegation approach (at least in MIT-Scheme’s basic implementation) is a parent class doesn’t have access to local state defined in a child class.</div></main><footer><p><a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode"id="copyright">© 2020 Sean Breckenridge. Licensed under Creative Commons Attribution-ShareAlike.</a><br><a href="https://github.com/seanbreckenridge/exobrain">Source Code</a></footer><script src="/assets/main.js"></script>